---
slug: memory-architecture
title: 프로그램 메모리 구조

authors: [brown]
tags: [memory, stack, heap]
Date: 2024-04-11 14:00
---

# 프로그램 메모리 구조

## Intro

요즘 램은 기본적으로 기가 단위 인것 같다. 본인이 초등학생 일 때 카트라이더을 하는데 너무 렉이 심해서, 어떻게 해야하지 알아보다 램을 사서 끼웠던 기억이 있다. 그 당시 컴퓨터들은 하드 10 ~ 25기가에 램은 256MB ~ 512MB가 일반적이었던 것 같다.

그 후에도, 학창시절 당시 신작 고사양 게임들(아이온,마영전 같은)이 출시하면 시작하곤 했었는데, 렉이 걸리거나 실행이 안되면, 한번 해보겠다고 그래픽카드도 바꿔보고, 드라이버도 업데이트하고, 포맷도 하는 등 다양한 시도를 했었던 기억이 난다.

그때 메모리가 부족하다는 에러도 여러번 봤던 것 같은데, 해당 내용에 대해 정리 해보겠다.

<!-- truncate -->

## 메모리란?

컴퓨터의 핵심 부품은 4가지로 CPU, 메모리(주 기억장치), 보조 기억장치, 입출력장치이다.

- CPU: 중앙처리장치(Central Processing Unit)로, 연산 및 제어 기능을 담당
- 주기억장치:
  - RAM(Random Access Memory): 메모리는 주로 RAM을 지칭하며, 읽기와 쓰기가 모두 가능하며, 빠른 속도로 데이터에 접근가능한 휘발성 메모리
  - ROM(Read Only Memory): 컴퓨터 부팅에 필요한 펌웨어, BIOS(Basic Input/Output System) 등을 저장하는 데 사용하는 읽기 전용 비휘발성 메모리
- 보조기억장치: 하드디스크, SSD(Solid State Drive), USB 메모리 등이 포함되며, 대용량의 데이터를 영구적으로 저장할 수 있는 비휘발성 메모리
- 입출력장치: 키보드, 마우스, 스피커, 프린터...

RAM(Random Access Memory)의 의미는 **어떤 메모리 주소에 접근(random access)하더라도 동일한 시간의 읽고 쓰기가 보장되는 것을 의미**한다(하드디스크와 같은 자기 디스크의 경우 데이터가 저장된 주소에 따라 접근하는 시간이 다름).

램에도 DRAM, SRAM, HBM등 종류가 다양한데(잘모름), 기본적인 동작원리는 내부의 트랜지스터로 전기 흐름을 제어 하여 데이터를 저장(전류가 흐를 때를 1, 전류가 흐르지 않을 때를 0)하는 부분일 것이다.

휘발성인 이유는 전기적 신호로 데이터를 저장하기에, 전원 종료시(전기 차단) 전부 0이 되기 때문이고, 보조기억장치들은 데이터를 물리적으로 저장하기에 휘발되지 않는 것이다.

## 프로그램의 사이즈가 가용 메모리 용량보다 크다면?

프로그램 실행과정은 사용자의 실행요청 -> 프로그램 정보를 메모리에 로드 -> 프로그램 코드를 실행 순이다.

게임이든, 내가 작성한 프로그램이던 컴퓨터가 실행 하려면 **반드시 프로그램의 코드와 데이터가 메모리에 로드** 되어야 한다.

그러면 컴퓨터의 가용 메모리보다 큰 프로그램은 실행할 수 없는 걸까? 원래는 그렇다.

이를 극복하기 위해 나온 기술이 가상메모리(Virtual Memory)로 가상메모리를 사용하면 하드디스크의 일부를 메모리처럼 사용하여 실제 물리 메모리보다 큰 용량의 메모리를 사용하는 것처럼 프로그램을 실행할 수 있게 된다.

핵심 개념은 5가지다.

- 가상 주소 공간(Virtual Address Space):
  - 각 프로세스는 자신만의 독립적인 가상 주소 공간을 가짐
  - 가상 주소 공간은 실제 물리 메모리보다 클 수 있음
- 페이징(Paging):
  - 가상 주소 공간과 물리 메모리를 일정한 크기의 블록(페이지)으로 나누어 관리하는 기술
    - 가상메모리의 주소 데이터들을 일정한 크기의 블록으로 쪼게 놓은걸 페이지(Page)
    - 물리메모리의 주소 데이터들을 일정한 크기의 블록으로 쪼게 놓은걸 프레임(Frame)
  - 프로세스의 가상 주소 공간은 페이지 단위로 물리 메모리에 매핑
- 페이지 테이블(Page Table):
  - 가상 주소와 물리 주소 간의 매핑 정보를 저장하는 자료구조
  - 각 프로세스는 자신의 페이지 테이블을 가짐
  - 페이지 테이블을 통해 가상 주소를 물리 주소로 변환
- 요구 페이징(Demand Paging):
  - 프로세스 실행에 필요한 페이지를 실제로 사용할 때 메모리에 로드하는 기법
  - 초기에는 프로세스의 모든 페이지를 메모리에 로드하지 않고, 필요한 페이지만 로드
- 페이지 폴트(Page Fault):
  - 프로세스가 접근하려는 페이지가 물리 메모리에 없을 때 발생하는 인터럽트
  - 페이지 폴트가 발생하면 운영체제는 **해당 페이지를 하드디스크에서 물리 메모리로 로드**하고, 프로세스의 실행을 재개
  - 새로운 페이지를 로드 하는 과정에서 기존에 로드 된 페이지와 교체 될 수 있음

## 프로세스 메모리 구조

메모리 로드과정에 문제가 없다면 프로그램이 실행된다. 여기서 잠깐 프로그램과 프로세스를 짚고 넘어가자면 클래스와 인스턴스처럼 프로그램을 실행 시키면 **해당 프로그램의 인스턴스인 프로세스**가 생성되어 실행되는 것이다.

**운영체제(OS)는 프로세스에게 동작하기 위한 메모리 공간을 할당해 주는데, 영역은 Code, Data, Stack, Heap으로 나뉜다.**
| 영역 | 설명 |
|------|------|
| Code(Text) | - 프로그램의 실행 가능한 명령어(기계어)들이 저장되는 영역 |
| Data | - 전역 변수, 정적 변수, 배열 등이 저장되는 영역<br /> - 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 해제 |
| Heap | - 동적 메모리 할당을 위해 사용되는 영역 <br /> - 유일하게 런타임 시 크기가 결정되는 영역<br /> - 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당 |
| Empty space | - Heap을 위한 여분 공간 |
| Stack | - 지역 변수, 함수 호출 시 전달되는 인자, 함수의 반환 주소 등이 저장되는 영역 <br /> - LIFO(Last-In-First-Out) 구조 <br /> - 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당 |

```
+-----------------------+
|       Stack           |
|         |             |
|         v             |
+-----------------------+
|                       |
|         Free          |
|                       |
|         ^             |
|         |             |
+-----------------------+
|         Heap          |
+-----------------------+
|         Data          |
+-----------------------+
|         Text          |
+-----------------------+
```

Code부터 낮은 메모리 주소로 시작해서 Stack까지 올라가며 스택은 높은 메모리 주소부터 사용한다.

> [과거에는, 스택 영역에 초과되는 크기의 데이터를 저장한 후 커널 영역에 침범해 데이터를 조작하여 관리자 권한같은 해킹이 잦았는데 이를 방지하기 위해 스택 영역은 큰 주소 값을 시작으로 점차 아래로 주소 값이 할당되는 것입니다.](https://hwan-shell.tistory.com/13)

스택과 heap에 대해 js를 연관지어 보자면, 원시 타입의 변수들은 데이터가 call stack 영역에 저장되고, 반면에 객체 타입의 변수들은 **실제 데이터는 Memory Heap 영역에 저장 되고, 데이터에 대한 참조 값(메모리 주소)이 stack 영역에 저장**된다.

그래서 객체 타입의 변수들은 얕은 복사가 되는 것이다.

js파일을 node로 실행시킨다면, node 프로세스를 실행하는 것이고, 위의 메모리 구조를 가진 프로세스가 동작할 것이다.

그리고 node 프로세스가 js를 실행 하는데, js code, Call stack, memory heap등 프로세스의 개념과 유사한 동작을한다.

뭔가 프로세스의 안의 프로세스 같은 느낌이다(js 실행환경 -> js).

예전부터 다른 원시값 변수과 다르게 문자열 타입은 데이터 사이즈가 가변적(UTF-16 한 글자당 2 bytes)인데도, call stack에 저장 된다는 것이 의아했는데,

call stack, memory heap 둘다 nodejs 프로세스의 heap 영역에 있을테니 어떻게보면 전부 heap에 저장되는 데이터들이니 사이즈가 상관이 없을 수도 있을 것 같다.

구현체마다 다를수 있겠지만, 사이즈가 일정 수준을 넘으면 내부적으로 스트링 객체를 활용해 heap에 저장하지 않을까 추측해본다.

## multi thread programming

일반적으로 프로세스는 독립적인 메모리 공간을 가지므로 다른 프로세스의 데이터에 직접 접근할 수 없다.

그러나 경우에 따라 프로세스 간에 데이터를 공유하거나 통신해야 할 때는 IPC(Inter-Process Communication)를 사용한다.

반면 멀티 스레드(프로세스 내에서 실행되는 독립적인 실행 흐름의 단위)의 경우 같은 프로세스 내에서 스택을 제외한 영역을 공유하기 때문에 오버헤드 없이 데이터 공유가 가능하다.

스레드들은 각각 자신만의 stack을 가지는데, **stack은 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 메모리 공간이기 때문에, 독립적인 스택을 가졌다는 것은 독립적인 함수 호출이 가능하다라는 의미**이다.

즉, stack을 가짐으로써 스레드는 독립적인 실행 흐름을 가질 수 있게 되는 것이다.

## garbage collection

## 메모리 관련 버그

### out of memory

메모리 부족(out of memory)은 프로세스가 필요로 하는 메모리 양이 시스템의 사용 가능한 메모리를 초과할 때 발생하는 상황으로, 더 이상 메모리를 할당받을 수 없게 되어 정상적인 실행이 불가능해진다.

- 과도한 메모리를 사용(시스템의 물리적 메모리가 부족한 경우)
- 메모리 누수(Memory Leak)가 발생하여 점진적으로 메모리가 고갈되는 경우

### Memory Leak

Memory Leak(메모리 누수)는 프로그램이 동적으로 할당한 메모리를 사용한 후 해제하지 않아 발생하는 문제입니다. 이로 인해 프로그램이 실행되는 동안 사용 가능한 메모리가 점진적으로 줄어들어 성능 저하, 불안정성, 또는 시스템 충돌을 일으킬 수 있습니다.

개념
동적 메모리 할당: 프로그램 실행 중에 필요한 메모리를 운영체제로부터 할당받는 것을 의미합니다. (예: C에서의 malloc(), C++에서의 new)
메모리 해제: 할당받은 메모리를 다 사용한 후에는 운영체제에 반환해야 합니다. (예: C에서의 free(), C++에서의 delete)
Memory Leak: 할당받은 메모리를 해제하지 않고 계속 누적되는 현상입니다.
원인
할당된 메모리를 해제하지 않는 경우: 프로그래머가 메모리 해제 코드를 작성하지 않거나 실수로 빼먹은 경우입니다.
할당한 메모리에 대한 포인터를 잃어버린 경우: 메모리를 가리키는 포인터를 덮어쓰거나 해제하면 해당 메모리에 접근할 수 없게 됩니다.
불필요한 객체 참조: 객체 간의 순환 참조 등으로 인해 garbage collector가 메모리를 해제하지 못하는 경우입니다. (Java, Python 등)
문제점
성능 저하: Memory Leak이 지속되면 사용 가능한 메모리가 점점 줄어들어 프로그램의 전반적인 성능이 저하됩니다.
불안정성: 메모리 부족 현상으로 인해 프로그램이 비정상적으로 동작하거나 예기치 않게 종료될 수 있습니다.
시스템 충돌: 심각한 메모리 부족 현상은 시스템 전체의 불안정을 야기하여 시스템 충돌로 이어질 수 있습니다.
해결 방안
메모리 할당 후 해제 코드 작성: 동적으로 할당한 메모리는 반드시 해제해야 합니다.
스마트 포인터 사용: C++의 unique_ptr, shared_ptr 등을 사용하여 메모리 해제를 자동화할 수 있습니다.
메모리 관리 도구 활용: Valgrind, Address Sanitizer 등의 도구를 사용하여 메모리 누수를 탐지하고 디버깅할 수 있습니다.
코드 리뷰 및 테스트: 코드 리뷰를 통해 메모리 누수 가능성을 검토하고, 테스트를 통해 메모리 사용량을 모니터링해야 합니다.
Memory Leak은 프로그램의 안정성과 성능에 직결되는 중요한 문제이므로, 프로그래머는 메모리 관리에 각별한 주의를 기울여야 합니다.

### buffer overflow

프로그램 내부의 메모리를 다루는 부분에서 오류가 발생하여 잘못된 동작을 하는 버그로 **데이터를 저장할 때 정해진 메모리의 영역을 초과하여 저장하는 것을 의미**한다.

벗어난 데이터는 인접 메모리를 덮어 쓰게 되며 이때 다른 데이터가 포함되어 있을 수도 있는데, 이로인해 메모리 접근 오류, 잘못된 결과, 프로그램 종료, 또는 시스템 보안 누설이 발생할 수 있다.

#### stack overflow

스택 오버플로우는 스택 메모리 영역에서 발생하는 버퍼 오버플로우의 한 종류로, 함수 호출 시 할당되는 스택 프레임의 중첩이 스택의 허용 범위(Maximum stacksize)를 초과할 때 발생한다.

[아래 코드로 브라우저의 Maximum stacksize를 테스트 해보자](https://stackoverflow.com/questions/7826992/browser-javascript-stack-size-limit)

```javascript
var i = 0;
function inc() {
  i++;
  inc();
}

try {
  inc();
} catch (e) {
  // The StackOverflow sandbox adds one frame that is not being counted by this code
  // Incrementing once manually
  i++;
  // RangeError: Maximum call stack size exceeded
  console.log("Maximum stack size is", i, "in your current browser");
}
```

#### stack buffer overflow

스택 버퍼 오버플로우는 함수 호출 시 할당되는 지역 변수들의 크기가 스택 메모리를 넘어서는 경우이다.

- 거의 볼 수 없는 경우
- 스택 메모리 사이즈를 변경하거나, 변수들의 사이즈를 줄여야 함

#### heap overflow

힙 오버플로우는 힙 메모리 영역에서 발생하는 버퍼 오버플로우

Heap Overflow 취약점은 공격자가 악의적으로 조작된 입력을 프로그램에 전달하여 프로그램의 흐름을 바꾸거나, 임의의 코드를 실행하는 등의 악의적인 행동을 할 수 있다.

방지 법

- 적절한 크기의 메모리 할당
- 경계 검사: 입력 데이터의 길이를 항상 검사하고, 할당된 메모리 크기를 초과하지 않도록 주의

### 그외

메모리를 직접 다루는 언어를 사용해 보지 않아 겪어보진 못했지만, 이러한 유형의 버그들이 있다고 한다.

- 이중 해제(Double Free): 이미 해제된 메모리를 다시 해제하려고 시도할 때 발생
- 초기화되지 않은 메모리 사용(Use of Uninitialized Memory):할당된 메모리를 초기화하지 않고 사용하는 경우 발생
- 널 포인터 역참조(Null Pointer Dereference): 널 포인터(유효한 메모리 주소X)를 역참조하여 접근하려고 할 때 발생

## js를 실행한다면?

## 참조

- 메모리란?
  - https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%95%B5%EC%8B%AC-%EB%B6%80%ED%92%88cpu-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5/
  - https://computing-jhson.tistory.com/21
- 프로그램의 사이즈가 가용 메모리 용량보다 크다면?
  - https://ahnanne.tistory.com/15#4.%20%EC%9A%94%EA%B5%AC%20%ED%8E%98%EC%9D%B4%EC%A7%95(demand%20paging)%EC%9D%B4%EB%9E%80?
- 프로세스 메모리 구조
  - https://tcpschool.com/c/c_memory_structure
- thread programming
  - https://dar0m.tistory.com/233
  - https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이
- garbage collection
- 메모리 관련 버그
  - https://hwan-shell.tistory.com/13
  - https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8D%BC_%EC%98%A4%EB%B2%84%ED%94%8C%EB%A1%9C
